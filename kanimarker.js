// Generated by CoffeeScript 1.9.3
var Kanimarker;

Kanimarker = (function() {
  Kanimarker.prototype.map = null;

  Kanimarker.prototype.headingUp = false;

  Kanimarker.prototype.position = null;

  Kanimarker.prototype.direction = 0;

  Kanimarker.prototype.accuracy = 0;

  Kanimarker.prototype.moveAnimationState_ = null;

  Kanimarker.prototype.directionAnimationState_ = null;

  Kanimarker.prototype.accuracyAnimationState_ = null;

  Kanimarker.prototype.fadeInOutAnimationState_ = null;

  function Kanimarker(map) {
    this.map = map;
    this.map.on('postcompose', this.postcompose_, this);
    this.map.on('precompose', this.precompose_, this);
    this.map.on('pointerdrag', this.pointerdrag_, this);
  }

  Kanimarker.prototype.cancelAnimation = function() {
    this.moveAnimationState_ = null;
    this.directionAnimationState_ = null;
    this.accuracyAnimationState_ = null;
    return this.fadeInOutAnimationState_ = null;
  };

  Kanimarker.prototype.setHeadingUp = function(newValue) {
    this.headingUp = newValue;
    this.cancelAnimation();
    if (this.position != null) {
      this.map.getView().setCenter(this.position.slice());
    }
    if (this.direction != null) {
      this.map.getView().setRotation(-(this.direction / 180 * Math.PI));
    }
    return this.map.render();
  };

  Kanimarker.prototype.setPosition = function(toPosition, accuracy, silent) {
    var _this, from, fromPosition;
    if (silent == null) {
      silent = false;
    }
    _this = this;
    if (this.moveAnimationState_ != null) {
      fromPosition = this.moveAnimationState_.current;
      this.moveAnimationState_ = null;
    } else {
      fromPosition = this.position;
    }
    if (toPosition === fromPosition) {
      return;
    }
    if ((toPosition != null) && (fromPosition != null)) {
      this.moveAnimationState_ = {
        start: new Date(),
        from: fromPosition.slice(),
        current: fromPosition.slice(),
        to: toPosition.slice(),
        animate: function(frameStateTime) {
          var time;
          time = (frameStateTime - this.start) / 2000;
          if (time <= 1) {
            this.current[0] = this.from[0] + ((this.to[0] - this.from[0]) * ol.easing.easeOut(time));
            this.current[1] = this.from[1] + ((this.to[1] - this.from[1]) * ol.easing.easeOut(time));
            return true;
          } else {
            _this.moveAnimationState_ = null;
            return false;
          }
        }
      };
    } else if (toPosition != null) {
      if (this.fadeInOutAnimationState_ != null) {
        from = this.fadeInOutAnimationState_.current;
      } else {
        from = 0;
      }
      this.fadeInOutAnimationState_ = {
        start: new Date(),
        from: from,
        current: from,
        to: 1,
        animationPosition: toPosition,
        animate: function(frameStateTime) {
          var time;
          time = (frameStateTime - this.start) / 500;
          if (time <= 1) {
            this.current = this.from + ((this.to - this.from) * (function(x) {
              return x;
            })(time));
            return true;
          } else {
            _this.fadeInOutAnimationState_ = null;
            return false;
          }
        }
      };
    } else {
      if (this.fadeInOutAnimationState_ != null) {
        from = this.fadeInOutAnimationState_.current;
      } else {
        from = 1;
      }
      this.fadeInOutAnimationState_ = {
        start: new Date(),
        from: from,
        current: from,
        to: 0,
        animationPosition: fromPosition,
        animate: function(frameStateTime) {
          var time;
          time = (frameStateTime - this.start) / 500;
          if (time <= 1) {
            this.current = this.from + ((this.to - this.from) * (function(x) {
              return x;
            })(time));
            return true;
          } else {
            _this.fadeInOutAnimationState_ = null;
            return false;
          }
        }
      };
    }
    this.position = toPosition;
    if (!silent) {
      this.map.render();
    }
  };


  /*
    現在地マーカーを非表示にする.
    表示するにはsetPosition()で現在地の場所を決める
   */

  Kanimarker.prototype.hide = function() {
    return this.setPosition(null);
  };


  /*
    現在地の周りの円の大きさを変える
    @param accuracy {Number} 広さ (メートル)
    @param silent {Boolean} renderをしない時に true にする. default: false
   */

  Kanimarker.prototype.setAccuracy = function(accuracy, silent) {
    var _this, from;
    if (silent == null) {
      silent = false;
    }
    _this = this;
    if (this.accuracyAnimationState_ != null) {
      from = this.accuracyAnimationState_.current;
      this.accuracyAnimationState_ = null;
    } else {
      from = this.accuracy;
    }
    this.accuracyAnimationState_ = {
      start: new Date(),
      from: from,
      current: from,
      animate: function(frameStateTime) {
        var time;
        time = (frameStateTime - this.start) / 2000;
        if (time <= 1) {
          this.current = this.from + ((_this.accuracy - this.from) * ol.easing.easeOut(time));
          return true;
        } else {
          _this.accuracyAnimationState_ = null;
          return false;
        }
      }
    };
    this.accuracy = accuracy;
    if (!silent) {
      return this.map.render();
    }
  };


  /*
    現在地マーカーの向きを設定する.
    @param newDirection {Number} 真北からの角度
   */

  Kanimarker.prototype.setDirection = function(newDirection, silent) {
    var _this, n, virtualDirection;
    if (silent == null) {
      silent = false;
    }
    if (newDirection > this.direction) {
      n = newDirection - this.direction;
      if (n <= 180) {
        virtualDirection = this.direction + n;
      } else {
        virtualDirection = this.direction - (360 - n);
      }
    } else {
      n = this.direction - newDirection;
      if (n <= 180) {
        virtualDirection = this.direction - n;
      } else {
        virtualDirection = this.direction + (360 - n);
      }
    }
    _this = this;
    this.directionAnimationState_ = {
      start: new Date(),
      from: this.direction,
      current: this.direction,
      to: virtualDirection,
      animate: function(frameStateTime) {
        var time;
        time = (frameStateTime - this.start) / 500;
        if (time <= 1) {
          this.current = this.from + ((this.to - this.from) * ol.easing.easeOut(time));
          return true;
        } else {
          _this.directionAnimationState_ = null;
          return false;
        }
      }
    };
    this.direction = newDirection;
    if (!silent) {
      return this.map.render();
    }
  };


  /*
    @private ol.Map on postcompose イベントリスナー ol.Map on から呼ばれる
   */

  Kanimarker.prototype.postcompose_ = function(event) {
    var accuracy, circleStyle, context, direction, frameState, iconStyle, opacity, pixel, pixelRatio, position, vectorContext;
    context = event.context;
    vectorContext = event.vectorContext;
    frameState = event.frameState;
    pixelRatio = frameState.pixelRatio;
    opacity = 1;
    position = this.position;
    accuracy = this.accuracy;
    direction = this.direction;
    if ((this.moveAnimationState_ != null) && this.moveAnimationState_.animate(frameState.time)) {
      position = this.moveAnimationState_.current;
      frameState.animate = true;
    }
    if ((this.directionAnimationState_ != null) && this.directionAnimationState_.animate(frameState.time)) {
      direction = this.directionAnimationState_.current;
      frameState.animate = true;
    }
    if ((this.fadeInOutAnimationState_ != null) && this.fadeInOutAnimationState_.animate(frameState.time)) {
      opacity = this.fadeInOutAnimationState_.current;
      position = this.fadeInOutAnimationState_.animationPosition;
      frameState.animate = true;
    }
    if ((this.accuracyAnimationState_ != null) && this.accuracyAnimationState_.animate(frameState.time)) {
      accuracy = this.accuracyAnimationState_.current;
      frameState.animate = true;
    }
    if (position != null) {
      circleStyle = new ol.style.Circle({
        radius: (accuracy / frameState.viewState.resolution) * pixelRatio,
        fill: new ol.style.Fill({
          color: "rgba(56, 149, 255, " + (0.2 * opacity) + ")"
        }),
        stroke: new ol.style.Stroke({
          color: "rgba(56, 149, 255, " + (0.8 * opacity) + ")",
          width: 1 * pixelRatio
        })
      });
      vectorContext.setImageStyle(circleStyle);
      vectorContext.drawPointGeometry(new ol.geom.Point(position), null);
      iconStyle = new ol.style.Circle({
        radius: 8 * pixelRatio,
        snapToPixel: false,
        fill: new ol.style.Fill({
          color: "rgba(0, 160, 233, " + (1.0 * opacity) + ")"
        }),
        stroke: new ol.style.Stroke({
          color: "rgba(255, 255, 255, " + (1.0 * opacity) + ")",
          width: 3 * pixelRatio
        })
      });
      vectorContext.setImageStyle(iconStyle);
      vectorContext.drawPointGeometry(new ol.geom.Point(position), null);
      context.save();
      if (this.headingUp) {
        context.translate(context.canvas.width / 2, context.canvas.height / 2);
      } else {
        pixel = this.map.getPixelFromCoordinate(position);
        context.translate(pixel[0] * pixelRatio, pixel[1] * pixelRatio);
      }
      context.rotate((direction / 180 * Math.PI) + frameState.viewState.rotation);
      context.scale(pixelRatio, pixelRatio);
      context.beginPath();
      context.moveTo(0, -25);
      context.lineTo(-10, -12);
      context.lineTo(10, -12);
      context.closePath();
      context.fillStyle = "rgba(0, 160, 233, " + (1.0 * opacity) + ")";
      context.strokeStyle = "rgba(255, 255, 255, " + (1.0 * opacity) + ")";
      context.lineWidth = 3;
      context.fill();
      context.stroke();
      context.restore();
    }
    $('#debug').text(JSON.stringify({
      '現在地ステータス': kanimarker.position,
      '回転': kanimarker.direction,
      '円のサイズ': kanimarker.accuracy,
      '表示/非表示': (kanimarker.position != null) ? '表示' : '非表示',
      '表示モード': kanimarker.headingUp ? '追従モード' : 'ビューモード',
      '移動中': (kanimarker.moveAnimationState_ != null) ? 'アニメーション中' : 'アニメーションなし',
      '回転中': (kanimarker.directionAnimationState_ != null) ? 'アニメーション中' : 'アニメーションなし',
      '円の拡大/縮小': (kanimarker.accuracyAnimationState_ != null) ? 'アニメーション中' : 'アニメーションなし',
      '表示/非表示': (kanimarker.fadeInOutAnimationState_ != null) ? 'アニメーション中' : 'アニメーションなし'
    }, null, 2));
  };


  /*
    @private ol.Map on precompose イベントリスナー ol.Map on から呼ばれる
   */

  Kanimarker.prototype.precompose_ = function(event) {
    var direction, frameState, position;
    frameState = event.frameState;
    if (this.position != null) {
      if (this.headingUp) {
        position = this.position;
        direction = this.direction;
        if (this.moveAnimationState_ != null) {
          if (this.moveAnimationState_.animate(frameState.time)) {
            position = this.moveAnimationState_.current;
          } else {
            this.map.getView().setCenter(this.position.slice());
          }
        }
        if (this.directionAnimationState_ != null) {
          if (this.directionAnimationState_.animate(frameState.time)) {
            direction = this.directionAnimationState_.current;
          } else {
            this.map.getView().setRotation(-(direction / 180 * Math.PI));
          }
        }
        frameState.viewState.center[0] = position[0];
        frameState.viewState.center[1] = position[1];
        frameState.viewState.rotation = -(direction / 180 * Math.PI);
      }
    }
  };


  /*
    @private マップがドラッグされた時に呼ばれる
   */

  Kanimarker.prototype.pointerdrag_ = function() {
    if (this.headingUp) {
      this.setHeadingUp(false);
    }
  };

  return Kanimarker;

})();

//# sourceMappingURL=kanimarker.js.map
