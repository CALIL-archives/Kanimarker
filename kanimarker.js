// Generated by CoffeeScript 1.9.3

/*
  OpenLayers 3 でマーカーを表示するクラス

  @example マーカーを 表示/非表示 する
    kanimarker = new Kanimarker(map)
    kanimarker.setPosition(point, accuracy = 50)
    kanimarker.setPosition(null)

  @author sakai@calil.jp
  @version 1.2
 */
var Kanimarker;

Kanimarker = (function() {
  var deepCopy;

  deepCopy = function(object) {
    return JSON.parse(JSON.stringify(object));
  };

  Kanimarker.prototype.map = null;

  Kanimarker.prototype.headingUp = false;

  Kanimarker.prototype.position = null;

  Kanimarker.prototype.direction = null;

  Kanimarker.prototype.accuracy = null;

  Kanimarker.prototype.positionAnimation = null;

  Kanimarker.prototype.directionAnimation = null;

  Kanimarker.prototype.circleAnimation = null;

  Kanimarker.prototype.opacityAnimation = null;


  /*
    mapを指定してマーカーを生成
    @param @map {ol.Map} - OpenLayers3 マップオブジェクト
    @classdesc OpenLayers3に現在地マーカーを表示するクラス.
    @constructor
   */

  function Kanimarker(map) {
    this.map = map;
    this.accuracy = 0;
    this.direction = 0;
    this.map.on('postcompose', this.postcompose_, this);
    this.map.on('precompose', this.precompose_, this);
    this.map.on('pointerdrag', this.pointerdrag_, this);
  }


  /*
    現在地を常に中心, マーカーの向きを画面上向きにするかどうかを設定する.
    @param headingUp {Boolean} する:true, しない: false
    @return 成功: true
   */

  Kanimarker.prototype.setHeadingUp = function(newHeadingUp) {
    if (newHeadingUp == null) {
      newHeadingUp = false;
    }
    this.headingUp = newHeadingUp;
    if (this.headingUp) {
      this.positionAnimation = null;
      this.directionAnimation = null;
      if (this.position != null) {
        this.map.getView().setCenter(deepCopy(this.position));
      }
      if (this.direction != null) {
        this.map.getView().setRotation(-(this.direction / 180 * Math.PI));
      }
    }
    return true;
  };

  Kanimarker.prototype.toCurrentPosition = function() {
    if (this.position != null) {
      this.map.getView().setCenter(deepCopy(this.position));
    }
  };


  /*
    現在地マーカーを移動する
    @param toPosition {Array} 現在地を描画する座標
    @param accuracy {Number} 円の広さ (メートル) 指定がない場合は変更されない
    @param silent {Boolean} renderをしない時に true にする. default: false
   */

  Kanimarker.prototype.setPosition = function(toPosition, accuracy, silent) {
    var _this, from, fromPosition;
    if (silent == null) {
      silent = false;
    }
    _this = this;
    if (this.positionAnimation != null) {
      fromPosition = this.positionAnimation.current;
      this.positionAnimation = null;
    } else {
      fromPosition = this.position;
    }
    if (toPosition === fromPosition) {
      return;
    }
    if ((toPosition != null) && (fromPosition != null)) {
      this.positionAnimation = {
        start: new Date(),
        from: deepCopy(fromPosition),
        current: deepCopy(fromPosition),
        to: deepCopy(toPosition),
        animate: function(frameStateTime) {
          var time;
          time = (frameStateTime - this.start) / 2000;
          if (time <= 1) {
            this.current[0] = this.from[0] + ((this.to[0] - this.from[0]) * ol.easing.easeOut(time));
            this.current[1] = this.from[1] + ((this.to[1] - this.from[1]) * ol.easing.easeOut(time));
            return true;
          } else {
            _this.positionAnimation = null;
            return false;
          }
        }
      };
    } else if (toPosition != null) {
      if (this.opacityAnimation != null) {
        from = this.opacityAnimation.current;
      } else {
        from = 0;
      }
      this.opacityAnimation = {
        start: new Date(),
        from: from,
        current: from,
        to: 1,
        animationPosition: toPosition,
        animate: function(frameStateTime) {
          var time;
          time = (frameStateTime - this.start) / 500;
          if (time <= 1) {
            this.current = this.from + ((this.to - this.from) * (function(x) {
              return x;
            })(time));
            return true;
          } else {
            _this.opacityAnimation = null;
            return false;
          }
        }
      };
    } else {
      if (this.opacityAnimation != null) {
        from = this.opacityAnimation.current;
      } else {
        from = 1;
      }
      this.opacityAnimation = {
        start: new Date(),
        from: from,
        current: from,
        to: 0,
        animationPosition: fromPosition,
        animate: function(frameStateTime) {
          var time;
          time = (frameStateTime - this.start) / 500;
          if (time <= 1) {
            this.current = this.from + ((this.to - this.from) * (function(x) {
              return x;
            })(time));
            return true;
          } else {
            _this.opacityAnimation = null;
            return false;
          }
        }
      };
    }
    this.position = toPosition;
    if (!silent) {
      this.map.render();
    }
  };


  /*
    現在地マーカーを非表示にする.
    表示するにはsetPosition()で現在地の場所を決める
   */

  Kanimarker.prototype.hide = function() {
    return this.setPosition(null);
  };


  /*
    現在地の周りの円の大きさを変える
    @param accuracy {Number} 広さ (メートル)
    @param silent {Boolean} renderをしない時に true にする. default: false
   */

  Kanimarker.prototype.setAccuracy = function(accuracy, silent) {
    var _this, from;
    if (silent == null) {
      silent = false;
    }
    _this = this;
    if (this.circleAnimation != null) {
      from = this.circleAnimation.current;
      this.circleAnimation = null;
    } else {
      from = this.accuracy;
    }
    this.circleAnimation = {
      start: new Date(),
      from: from,
      current: from,
      animate: function(frameStateTime) {
        var time;
        time = (frameStateTime - this.start) / 2000;
        if (time <= 1) {
          this.current = this.from + ((_this.accuracy - this.from) * ol.easing.easeOut(time));
          return true;
        } else {
          _this.circleAnimation = null;
          return false;
        }
      }
    };
    this.accuracy = accuracy;
    if (!silent) {
      return this.map.render();
    }
  };


  /*
    現在地マーカーの向きを設定する.
    @param newDirection {Number} 真北からの角度
   */

  Kanimarker.prototype.setDirection = function(newDirection, silent) {
    var _this, n, virtualDirection;
    if (silent == null) {
      silent = false;
    }
    if (newDirection > this.direction) {
      n = newDirection - this.direction;
      if (n <= 180) {
        virtualDirection = this.direction + n;
      } else {
        virtualDirection = this.direction - (360 - n);
      }
    } else {
      n = this.direction - newDirection;
      if (n <= 180) {
        virtualDirection = this.direction - n;
      } else {
        virtualDirection = this.direction + (360 - n);
      }
    }
    _this = this;
    this.directionAnimation = {
      start: new Date(),
      from: this.direction,
      current: this.direction,
      to: virtualDirection,
      animate: function(frameStateTime) {
        var time;
        time = (frameStateTime - this.start) / 500;
        if (time <= 1) {
          this.current = this.from + ((this.to - this.from) * ol.easing.easeOut(time));
          return true;
        } else {
          _this.directionAnimation = null;
          return false;
        }
      }
    };
    this.direction = newDirection;
    if (!silent) {
      return this.map.render();
    }
  };


  /*
    @private ol.Map on postcompose イベントリスナー ol.Map on から呼ばれる
   */

  Kanimarker.prototype.postcompose_ = function(event) {
    var accuracy, circleStyle, context, direction, frameState, iconStyle, opacity, pixel, pixelRatio, position, vectorContext;
    context = event.context;
    vectorContext = event.vectorContext;
    frameState = event.frameState;
    pixelRatio = frameState.pixelRatio;
    opacity = 1;
    position = this.position;
    accuracy = this.accuracy;
    direction = this.direction;
    if ((this.positionAnimation != null) && this.positionAnimation.animate(frameState.time)) {
      position = this.positionAnimation.current;
      frameState.animate = true;
    }
    if ((this.directionAnimation != null) && this.directionAnimation.animate(frameState.time)) {
      direction = this.directionAnimation.current;
      frameState.animate = true;
    }
    if ((this.opacityAnimation != null) && this.opacityAnimation.animate(frameState.time)) {
      opacity = this.opacityAnimation.current;
      position = this.opacityAnimation.animationPosition;
      frameState.animate = true;
    }
    if ((this.circleAnimation != null) && this.circleAnimation.animate(frameState.time)) {
      accuracy = this.circleAnimation.current;
      frameState.animate = true;
    }
    if (position != null) {
      circleStyle = new ol.style.Circle({
        radius: (accuracy / frameState.viewState.resolution) * pixelRatio,
        fill: new ol.style.Fill({
          color: "rgba(56, 149, 255, " + (0.2 * opacity) + ")"
        }),
        stroke: new ol.style.Stroke({
          color: "rgba(56, 149, 255, " + (0.8 * opacity) + ")",
          width: 1 * pixelRatio
        })
      });
      vectorContext.setImageStyle(circleStyle);
      vectorContext.drawPointGeometry(new ol.geom.Point(position), null);
      iconStyle = new ol.style.Circle({
        radius: 8 * pixelRatio,
        snapToPixel: false,
        fill: new ol.style.Fill({
          color: "rgba(0, 160, 233, " + (1.0 * opacity) + ")"
        }),
        stroke: new ol.style.Stroke({
          color: "rgba(255, 255, 255, " + (1.0 * opacity) + ")",
          width: 3 * pixelRatio
        })
      });
      vectorContext.setImageStyle(iconStyle);
      vectorContext.drawPointGeometry(new ol.geom.Point(position), null);
      context.save();
      if (this.headingUp) {
        context.translate(context.canvas.width / 2, context.canvas.height / 2);
      } else {
        pixel = this.map.getPixelFromCoordinate(position);
        context.translate(pixel[0] * pixelRatio, pixel[1] * pixelRatio);
      }
      context.rotate((direction / 180 * Math.PI) + frameState.viewState.rotation);
      context.scale(pixelRatio, pixelRatio);
      context.beginPath();
      context.moveTo(0, -25);
      context.lineTo(-10, -12);
      context.lineTo(10, -12);
      context.closePath();
      context.fillStyle = "rgba(0, 160, 233, " + (1.0 * opacity) + ")";
      context.strokeStyle = "rgba(255, 255, 255, " + (1.0 * opacity) + ")";
      context.lineWidth = 3;
      context.fill();
      context.stroke();
      context.restore();
    }
    $('#debug').text(JSON.stringify({
      '現在地ステータス': kanimarker.position,
      '回転': kanimarker.direction,
      '円のサイズ': kanimarker.accuracy,
      '表示/非表示': (kanimarker.position != null) ? '表示' : '非表示',
      '表示モード': kanimarker.headingUp ? '追従モード' : 'ビューモード',
      '移動中': (kanimarker.positionAnimation != null) ? 'アニメーション中' : 'アニメーションなし',
      '回転中': (kanimarker.directionAnimation != null) ? 'アニメーション中' : 'アニメーションなし',
      '円の拡大/縮小': (kanimarker.circleAnimation != null) ? 'アニメーション中' : 'アニメーションなし',
      '表示/非表示': (kanimarker.opacityAnimation != null) ? 'アニメーション中' : 'アニメーションなし'
    }, null, 2));
  };


  /*
    @private ol.Map on precompose イベントリスナー ol.Map on から呼ばれる
   */

  Kanimarker.prototype.precompose_ = function(event) {
    var direction, frameState, position;
    frameState = event.frameState;
    if (this.position != null) {
      if (this.headingUp) {
        position = this.position;
        direction = this.direction;
        if (this.positionAnimation != null) {
          if (this.positionAnimation.animate(frameState.time)) {
            position = this.positionAnimation.current;
          } else {
            this.map.getView().setCenter(deepCopy(this.position));
          }
        }
        if (this.directionAnimation != null) {
          if (this.directionAnimation.animate(frameState.time)) {
            direction = this.directionAnimation.current;
          } else {
            this.map.getView().setRotation(-(direction / 180 * Math.PI));
          }
        }
        frameState.viewState.center[0] = position[0];
        frameState.viewState.center[1] = position[1];
        frameState.viewState.rotation = -(direction / 180 * Math.PI);
      }
    }
  };


  /*
    @private マップがドラッグされた時に呼ばれる
   */

  Kanimarker.prototype.pointerdrag_ = function() {
    if (this.headingUp) {
      this.setHeadingUp(false);
    }
  };

  return Kanimarker;

})();

//# sourceMappingURL=kanimarker.js.map
